---
title: "downsize"
author: "Will Landau"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{downsize}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Tutorial

If you have a time-consuming workflow, it may be prudent to try a scaled-down
dry run first. If you intersperse your code with enough calls to `downsize()`, 
it is trivially easy to scale the workload up or down. 
That way, your entire workflow becomes a quick unit test with as little change as possible.

## Toggle objects

Say you want to analyze a large dataset.

```{r}
big_data <- data.frame(x = rnorm(1e4), y = rnorm(1e4))
```

But for the sake of time, you want to test and debug your code on a smaller dataset.

```{r}
small_data <- head(big_data, n = 6)
```

In your code, select your dataset with a call to `downsize()`.

```{r}
library(downsize)
my_data <- downsize(big_data, small_data)
```

In this basic usage, the `downsize()` function provides a choice between the two arguments. It executes `my_data <- big_data` if `getOption("downsize")` is `FALSE` or `NULL` (default) and `my_data <- small_data` if `getOption("downsize")` is `TRUE`. 
You can toggle the global option `downsize` with calls to `scale_up()` and `scale_down()`, and you can override the option with `downsize(..., downsize = L)`, where `L` is `TRUE` or `FALSE`. You can also check the `downsize` option with the `scaling()` function, as in these examples.

```{r}
scale_down()
scaling() # getOption("downsize") is TRUE
my_data <- downsize(big_data, small_data)
all(my_data == small_data)
scale_up()
scaling() # getOption("downsize") is FALSE
my_data <- downsize(big_data, small_data)
all(my_data == big_data)
```

## Toggle subsetting

In the previous example, `my_data <- downsize(big_data, small_data)` is equivalent to `my_data <- downsize(big_data, nrow = 6)`. There are multiple ways to subset the argument called `big` when it is time to scale down.

```{r}
scale_down()
downsize(1:10, length = 2)
m <- matrix(1:36, ncol = 6)
downsize(m, ncol = 2)
downsize(m, nrow = 2)
downsize(m, dim = c(2, 2))
downsize(data.frame(x = 1:10, y = 1:10), nrow = 5)
dim(downsize(array(0, dim = c(10, 100, 2, 300, 12)), dim = rep(3, 5)))
```

Set `random` to `TRUE` to take a random subset of your data.

```{r}
set.seed(6)
downsize(m, ncol = 2, random = T)
```

## Toggle code blocks

You can interchange entire blocks of code based on the scaling of the workload.

```{r}
scale_down()
downsize(big = {a = 1; a + 10}, small = {a = 1; a + 1})
scale_up()
downsize(big = {a = 1; a + 10}, small = {a = 1; a + 1})
```

Variables set in the code blocks are available after calls to `downsize()`.

```{r}
scale_down()
tmp <- downsize(
  big = {
    x = "long code"
    y = 1:10
  }, 
  small = {
    x = "short code"
    y = 3.14
  })
identical(x, "short code")
identical(y, 3.14)
scale_up()
tmp <- downsize(
  big = {
    x = "long code"
    y = 1:10
  }, 
  small = {
    x = "short code"
    y = 3.14
  })
identical(x, "long code")
identical(y, 1:10)
```


# Troubleshooting

Please refer to [TROUBLESHOOTING.md](https://github.com/wlandau/downsize/blob/master/TROUBLESHOOTING.md) on the [GitHub page](https://github.com/wlandau/downsize) for instructions.
